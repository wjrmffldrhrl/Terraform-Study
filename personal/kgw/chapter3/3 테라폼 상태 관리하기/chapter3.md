# 3. 테라폼 상태 관리하기

## 1. 테라폼 상태란?

- terraform.tfstate 파일에 .tf에 기록하였던 테라폼 리소스가 실제 리소스의 표현으로 매핑되는 내용을 기록하는 사용자 정의 JSON 형식으로 저장되어 있음.
- `terraform apply` 를 실행할 때마다 인프라의 최신 상태를 가져와서 어느 변경 사항을 적용해야 할 지 결정할 수 있다.
- 혼자 사용할 때는 state 파일을 로컬에 저장해두면 되지만 공유할 때는 문제가 생길 수 있음.
    - 수동오류: 상태 파일을 저장하기 때문에 팀원들이 모두 동일한 상태 파일을 가져야 한다.
    - 잠금: 잠금 기능 없이 여러 버전의 상태 파일을 동시에 업데이트하면 서로 다른 인프라 상태가 충돌할 수 있다.
    - 격리: 모든 인프라가 하나의 상태 파일에 정의되어 있다면 환경 격리가 어려워진다.

## 2. 상태 파일 공유

- 상태 파일 공유의 가장 일반적인 방법 ⇒ **Git 이용**
- 하지만 몇 가지 문제점
    - 푸시하는 걸 까먹어서 충돌
    - 잠금 기능 제공X
    - 시크릿키 관리 어려움: 모든 데이터가 plain text로 저장되기 때문에 보안에 취약
- 이를 해결하기 위해 **테라폼 백엔드** 사용
    - 테라폼을 실행할 때마다 백엔드에서 상태파일을 자동 저장
    - 잠금 기능 제공 `-lock-timeout` 파라미터를 통해 잠금 timeout을 지정할 수 있다.
    - 상태 파일이 자동으로 암호화되기 때문에 대부분의 보안 문제 해결
- AWS에서는 S3를 이용하는 것이 좋다.
- 회사에서는 Terraform Cloud를 사용중인데 인원이 다 차서 사용할 수가 없다 ㅠㅠ
    - 만약 케빈이 이걸로 했다면 공유해주셨으면…
- S3
- 다이나모 DB
    - 잠금에 다이나모DB를 사용한다는게 굉장히 신기
    - 내 기억상으로는 NoSQL은 트랜잭션을 지원하지 않아 일관성을 보장하기 어렵다고 들었는데(수정보다 삽입 연산에 최적화) 다이나모를 사용하는 이유가 뭘까?
- 테라폼 백엔드

    ```
    terraform {
    	backend "s3" {
    		bucket = ""
    		key = ""
    		region = ""
    	}

    	dynamodb_table = ""
    	encrypt = true
    }
    ```

    - `terraform init` 명령을 통해 백엔드 구성. 멱등성이 있어서 계속해서 실행해도 안전
- 테라폼이 S3에 상태 데이터를 자동으로 푸시하고, 가져오고, 모든 변경 사항을 적용한다.

## 3. 테라폼 백엔드의 단점

1. 생성할 땐 상태 파일 저장소 먼저 배포 후 backend 구성에 추가하여 init, 삭제할 땐 backend 구성을 제거하고 init하여 로컬에 동기화한 뒤 삭제(해체는 조립의 역순)
    1. 조금 귀찮은 거 말고는 딱히 단점이라고 못 느끼겠음
2. backend 블록에서는 변수나 참조를 사용할 수 없음. 수동 변경 작업이 잦다면 에러가 발생할 수 있다.
    1. `-backend-config` 인수로 매개 변수 전달
    2. `.hcl` 파일로 저장하여 관리
    3. `terraform init -backend-config=backend.hcl`
    4. 테라그런트로도 관리 가능

## 4. 상태 파일 격리

- 단 하나의 상태 파일에서 모든 인프라를 관리하면 전체가 위험해질 수 있다.

### 1. terraform workspace를 통한 격리

- terraform workspace를 통해 별도의 이름을 가진 여러 개의 작업공간에 상태를 저장
- `terraform workspace new <workspace_name>` 으로 작업 공간 생성
    - apply를 하면 완전히 다른 인프라 구성
    - 그 밖에 `show, list, select`
    - default를 제외한 다른 격리 공간은 `env:` 에 위치
- 단점
    - 동일한 백엔드에 저장되기 때문에 완전한 환경 격리X
    - 현재 위치한 workspace에 대한 파악이 어렵다

    ⇒ 빠르게 환경을 만들어 테스트해 볼 수는 있지만 만약 현재 위치를 잘못 파악하고 apply를 하면 재앙


### 2. 파일 레이아웃을 이용한 격리

- 제대로 된 격리를 하기 위해 해야하는 것
    - 상태 파일을 분리된 폴더에서 관리
    - 서로 다른 인증 메커니즘과 엑세스 제어 사용
- 각 환경(스테이징, 프로덕션)과 각 구성요소를 별도의 폴더와 파일에서 관리해야 한다.
- 파일 레이아웃

    ![Untitled](3%20%E1%84%90%E1%85%A6%E1%84%85%E1%85%A1%E1%84%91%E1%85%A9%E1%86%B7%20%E1%84%89%E1%85%A1%E1%86%BC%E1%84%90%E1%85%A2%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%206f9c7730a77147e083cb3fdd2598ac90/Untitled.png)

- `[main.tf](http://main.tf)` 가 커져서 기능이 너무 많아진다면 각 기능별로 `tf` 파일을 나눌 수도 있지만 더 작은 모듈로 나누는 것을 고려해보아야 함.
- 이렇게 다 따로 관리하면 운영이 조금 귀찮을 거 같다고 생각
    - 구성 요소가 별도의 폴더에 있는 개별 구성 요소 각각에 `terraform apply` 를 실행해야 함
    - 리소스 종속성은 terrform_remote_state라는 솔루션으로 해결

## 5. terrform_remote_state 데이터 소스

<aside>
💡 데이터 소스 리마인드
테라폼을 실행할 때마다 공급자에서 가져온 읽기 전용 정보

</aside>

- 시크릿 키 리소스로 전달하는 법
    - 공급자의 시크릿 저장소에서 데이터 소스로 읽기
    - 외부의 서드파티 암호 도구로 관리하여 환경변수로 넘겨주기
        - `export TF_VAR_db_password=1234`

            ![스크린샷 2022-12-08 오후 10.13.17.png](3%20%E1%84%90%E1%85%A6%E1%84%85%E1%85%A1%E1%84%91%E1%85%A9%E1%86%B7%20%E1%84%89%E1%85%A1%E1%86%BC%E1%84%90%E1%85%A2%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%206f9c7730a77147e083cb3fdd2598ac90/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-12-08_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.13.17.png)

        - `export TF_VAR_db_password=4321`

            ![스크린샷 2022-12-08 오후 10.14.16.png](3%20%E1%84%90%E1%85%A6%E1%84%85%E1%85%A1%E1%84%91%E1%85%A9%E1%86%B7%20%E1%84%89%E1%85%A1%E1%86%BC%E1%84%90%E1%85%A2%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%206f9c7730a77147e083cb3fdd2598ac90/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-12-08_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.14.16.png)

            ![스크린샷 2022-12-08 오후 10.15.22.png](3%20%E1%84%90%E1%85%A6%E1%84%85%E1%85%A1%E1%84%91%E1%85%A9%E1%86%B7%20%E1%84%89%E1%85%A1%E1%86%BC%E1%84%90%E1%85%A2%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%206f9c7730a77147e083cb3fdd2598ac90/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-12-08_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.15.22.png)

    - 근데 이렇게 해도 코드에는 시크릿 값이 하드하게 박혀있지 않지만 테라폼 상태 파일에는 항상 평문으로 저장된다.
        - 상태 파일 실험

```
data "terraform_remote_state" "db" {
  backend = "s3"

  config = {
    bucket = var.db_remote_state_bucket
    key    = var.db_remote_state_key
    region = "us-east-2"
  }
}
```

- 모든 데이터베이스 출력 변수는 상태 파일에 저장
    - `data.terrform_remote_state.<NAME>.outputs.<ATTRIBUTE>`
