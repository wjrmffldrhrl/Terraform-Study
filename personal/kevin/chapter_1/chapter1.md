# 챕터1

# DevOps의 혜성 같은 등장

- 기존에는 소프트웨어 코드를 작성하는 Developer와 이들이 돌아가는 하드웨어를 운영하는 Operator가 따로 있었음. 따라서 Developer가 작성한 코드를 Operator한테 메뉴얼하게 핸드 오버하는 방식으로 코드 배포가 이루어졌음
- 하지만 회사가 커질 때 이러한 방식은 문제를 일으키며 Operator들디 실수를 할 때 종종 snowflake 서버(설정에서 실수가 발생한 서버를 지칭함)이 발생하며 버그가 점점 많아짐. 그 와중에 Developer들은 “제 컴에서는 되는데요 으쓱^^” 을 시전함
- 따라서 Operator들은 매 배포마다 퇴근 시간이 늦어지고 힘들어짐에 따라 배포 주기를 일주일 → 한 달 → 반기로 미루게 됨. 그러다 보니 점점 더 큰 덩어리로 배포가 발생하면서 버그도 많아지고 서로를 탓하게 되는 경우가 발생함
- 이러한 상황을 해결하기 위해 `DevOps` 라는 움직임이 태동하였으며 이것은 팀, 직함, 특정 기술에 대한 단어가 아니며 일종의 프로세스, 아이디어, 테크닉을 의미하는 것임
- 다양한 회사들이 `DevOps` 를 차용하면서 큰 성과를 거두고 있음
- `DevOps` 에는 `culture` , `automation` , `measurement` , `sharing` 이라는 4가지 핵심 가치를 가지고 있는데 이 책에서는 이 중 Terraform을 활용해서 `automation` 에 특히 집중한다. 그리고 `automation` 의 골은 인프라 스트럭처를 관리할 때 클릭하는 것이 아니라 마치 소프트웨어 코드가 개발되어 배포되듯이 하는 것에 있다

# IAC는 뭘까?

- IAC의 아이디어의 핵심은 인프라 스트럭처의 정의, 배포, 업데이트, 삭제(일종의 CRUD 과정)을 모두 코드로 진행하는 것임. 특히 물리적인 하드웨어 자체도 코드로 소프트웨어로 여기는 것에 있다.
- IAC의 5가지 카테고리는 다음과 같다
    - Ad Hoc 스크립트 툴
    - 설정 관리 툴
    - 서버 템플릿팅 툴
    - 오케스트레이션 툴
    - 프로비저닝 툴
    

## Ad hoc 스크립트 툴

어떤 서버의 세팅을 자동화하기 위해 우리는 간단한 스크립트를 작성할 수 있다. 이런 스크립트의 장점은 우리가 원하는대로 좋아하는 범용 프로그래밍 언어를 활용해서 작성할 수 있다는 점이며, 이건 단점이기도 하다.

특히 범용 프로그래밍 언어를 활용할 때의 가장 큰 단점은 코드를 커스텀하게 짜야 한다는 점이며, IAC를 위해서는 특정 구조를 가지도록 짜야 하는데 범용 프로그래밍 언어에서는 각 개발자들이 모두 자신이 원하는 형태로 짤 수 있기 때문에 점점 스파게티가 될 가능성이 높다. 

따라서 Ad hoc 스크립트는 작고 간단한 작업을 위해서는 훌륭할 수 있지만, 전체 인프라를 다루기 위해서는 IaC를 위해 설계된 툴을 활용하는 것이 바람직하다 

## 설정 관리 툴

Chef, Puppet, Ansible, SaltStack과 같은 툴은 설정 관리 툴임. Ansible 코드의 경우 Ad hoc 스크립트와 비교해보았을 때 다음과 같은 장점을 가진다.

- Coding conventions : Ansible은 문서와 파일 배치, 파라미터, 시크릿을 모두 일관성 있고 예측 가능한 구조로 유지하도록 강제하게 된다. 따라서 조직 내에서 이들을 관리하고 특정 리소스를 찾아들어가기에 훨씬 용이해진다.
- Idempotence(멱등성) : ad hoc 스크립트가 한 번 실행되도록 하는 것은 그리 어렵지 않다. 그러나 여러번 실행시켜도 동일한 결과를 만들어 내게 하기에는 어려울 수 있으며 그 이유는 이미 설치한 것들이 있는지 If 문으로 체크해야 되는 경우가 자주 발생하기 때문이다. 이러한 If 문들에 의해서 코드가 매우 복잡해질 수 있다. 이때 Ansible은 기본적으로 멱등성을 챙겨주기 때문에 이미 깔린 패키지를 다시 깔지 않는다
- Distribution(분산) : Ad hoc 스크립트는 단일 머신에서만 실행될 수 있지만, Ansible 같은 설정 관리 툴은 큰 규모의 여러 대의 원격 서버에서 실행될 수 있다 예를 들면, Ansible Playbook 에서 원격 서버들의 주소를 기입하고, 플레이북을 실행시키면 병렬적으로 실행되게 할 수 있다. 혹은 `serial` 이라는 파라미터를 지정하면 한번에 한 서버씩 순차적으로 배포되는 `rolling deployment` 를 수행할 수도 있다

## 서버 템플릿팅 툴

설정 관리 툴의 대안책으로는 Docker, Packer, Vagrant이 있는데 이들은 기본 아이디어는 운영에 필요한 것들이 모두 포함되어 있는 일종의 서버 스냅샷을 이미지로 만들어서 서버 자체를 템플릿화 시키는 것이다. 예를 들면 Packer를 이용해서 서버에 필요한 디펜던시를 설치하고 Ansible로 배포하는 것이 가능하다

이때 이미지를 다루는 툴들에는 크게 두가지 종류가 있다. 

- Virtual Machine : 가상 머신은 하드웨어를 포함한 컴퓨터 시스템 전체를 에뮬레이트한다. VMWare, VirtualBox, Parallels와 같은 Hypervisor를 사용해서 CPU, 메모리, 하드 드라이브, 네트워크를 시뮬레이션하게 된다. VM 이미지의 장점은 hypervisor 위에서 모든 것이 돌아가기 때문에 호스트 머신으로부터 완벽하게 고립시킨 환경에서 VM 이미지를 실행시킬 수 있다. VM 이미지의 단점은 각 가상 머신마다 OS부터 독립적으로 실행시키기 위해서 CPU, 메모리, 시작 시간 등의 관점에서 오버헤드가 발생할 수 있다. Packer와 Vagrant를 사용하면 VM 이미지를 코드 처럼 관리할 수 있다.
- Containers : 컨테이너는 OS 상의 유저 스페이스(사용자 공간)을 에뮬레이트한다. Docker, CoreOS rkt, Cri-o 와 같은 컨테이너 엔진들이 있으며 이들은 프로세스, 메모리, 마운팅 위치, 네트워크를 가상화 시킨다. 컨테이너들은 자신의 유저 스페이스만 볼 수 있기 때문에 호스트 머신으로부터 완전히 독립적이며 어떤 환경에서 실행되더라도 동일하게 작동한다. 한가지 단점은 서버의 OS 커널과 하드웨어를 공유하기 떄문에 가상 머신(VM)을 사용하는 것보다는 고립의 정도와 보안 이슈가 발생할 수 있다. 그럼에도 불구하고, 커널과 하드웨어를 공유하기 때문에 컨테이너는 밀리세컨드 이내에 실행이 가능하며 CPU나 메모리 오버헤드가 거의 없다.

Packer를 예시로 들자면 AWS 서버를 돌릴 수 있는 AMI를 코드로부터 만들 수 있다. 이때 서버 템플릿팅 툴마다 목적이 조금씩 다른데 Packer는 AWS 환경에서 사용하기 위한 AMI를 만드는데 그 목적이 있고, Vagrant는 개발 환경에서 쓰기 위한 이미지를 만드는데 목적이 있다. 도커는 각각의 어플리케이션 이미지를 만드는데 목적이 있다. 

일반적인 사용 패턴은 Packer로 도커 엔진이 깔린 AMI를 만들고 그 위에서 어플리케이션 도커 이미지를 실행할 수 있다. 

서버 템플릿팅은 불변한 인프라스트럭쳐의 핵심 요소이며 변수들이 불변하기 때문에 바꿀 수 없으며 업데이트를 위해서는 삭제 후에 다시 생성해야 한다. 

## 오케스트레이션 툴

서버 템플릿팅 툴은 가상머신과 컨테이너를 생성하는데는 훌륭하지만, 이들을 실제로는 관리하기 위해서는

- 가상머신과 컨테이너 띄우기
- 순차 배포, 블루 그린 배포, 카나리 배포
- 각각의 가상머신과 컨테이너들의 헬스 체크를 진행하고 문제가 있는 경우에 갈아 끼우기
- 부하에 따라서 배포 수를 조정하기
- 각 가상머신과 컨테이너들에 트래픽 분산시키기
- 각각의 가상머신과 컨테이너들이 서로 통신할 수 있도록 네트워크 설정하기

이들을 관리하는 것이 오케스트레이션 툴이며, Kubernetes, Marathon/Mesos, Amazon ECS, Docker Swarm 등의 툴이 있다. 

## 프로비저닝 툴

설정 툴과 서버 템플릿팅 툴은 각 서버에서 돌아갈 것을 코드로 관리한다면, Terraform, CloudFormation, OpenStack Heat와 같은 프로비저닝 툴은 서버 자체를 생성하는데 역할이 있다. 그리고 서버 뿐만 아니라 데이터 베이스, 캐시, 로드 밸런서, 큐, 모니터링, 서브넷 설정, 방화벽, 라우팅, SSL 인증서 등등 인프라 스트럭처의 거의 모든 요소를 관리할 수 있다. 

예를 들자면, EC2 인스턴스, 데이터 베이스 등을 간단한 yaml 파일로 설정하면 그대로 만들어준다. 

# IaC의 장점

- Self-service : 기존에는 소수의 인원이 인프라를 담당했기 때문에 조직이 커졌을 때 병목으로 작용하지만, 코드로 정의되어있으면 배포를 자동화할 수 있고 각 개발자들이 직접 참여할 수 있음
- Speed and safety : 코드로 되어 있으면 수동으로 하는 것보다 빠르고 자동화 할 수 있으며 더 안전해질 수 있다
- Documentation : 기존에는 모든 인프라가 관리자 대가리에만 있었다면 코드로 명시하면 누구나 보고 이해할 수 있다
- Version Control : 인프라가 코드로 선언되어 있기 때문에 코밋 로그가 남고, 언제 어떤 변경들이 있었는지 파악하기에 용이하다
- Validation : 코드로 되어 있기 때문에 모든 변경사항마다 코드 리뷰와 자동화된 테스트 등을 수행할 수 있기 때문에 문제를 예방할 수 있다
- Reuse : 각각의 인프라들을 모듈화시키기 때문에 재활용 성이 높아진다
- Happiness : 기존에 수동으로 배포하는 과정은 매우 반복적이고 괴로운 일이지만 이것을 수동으로 한다는 것이 매우 행복한 일이 된다

# 테라폼과 다른 IaC 툴과의 비교

### Configuration Management Versus Provisioning

- 서버 템플릿팅 툴을 사용하는 것이 아니라면, 설정 관리 툴과 프로비저닝 툴을 가능하다면 같이 써라 (음?)

### Mutable Infrastructure Versus Immutable Infrastructure

- Mutable한 방식으로 인프라를 업데이트하게 되면, 기존에 잔존하던 코드과 신규 코드가 서로 이상한 결과를 만들어 내기 때문에 온전한 재연이 불가능할 수 있다
- Terraform은 새로운 변경 사항에 대해서 완전히 새로운 인프라를 만드는 방식으로 작동함
    > Q. 서버가 아니라 데이터가 잔존하게 되는 데이터베이스 계열의 인프라는 어떻게 되는거지? 업데이트하면 데이터가 다 날아가나?

### Procedural Language Versus Declarative Language

- 절차형 언어들은 말그대로 스텝 바이 스텝 가이드이기 때문에 동일한 코드를 여러번 실행하면 중복된 결과가 나올 수 있다 (멱등성이 없음)
- 선언형 언어들은 말그래도 선언하는 것이기 때문에 값을 바꾸면 변경된 상태로 맞춰진다. 즉 코드가 인프라의 최신 상태를 나타낸다
    - 물론 재배포 사이에 발생하는 다운타임 등이 코드에는 없지만 실제 환경에서는 발생할 수 있기 때문에 완벽하게 인프라 상태를 항상 나타낸다고 보기에 어려울 수 있으며 이러한 상황에 대비하기 위한 옵션들이 있음

### Master Versus Masterless

- Master 서버가 전체 인프라를 총괄하는 방식은 중앙에서 관리할 수 있다는 장점이 있지만, 유지보수 해야 될 인프라가 추가되고, 보안상 취약점으로 작용할 수 있다는 단점이 있다
- Terraform은 엄밀히 말하면 Provider사들이 제공하는 API 서버가 일종의 Master 서버 형태로 활용된다. Provider API는 Provider들이 유지보수하기 때문에 사용자 입장에서는 마치 Masterless하게 느껴진다.

### Agent Versus Agentless

- 각 서버에서 Agent가 설치되는 방식이 있는데 최초에 깔아야 한다는 불편함, Agent 소프트웨어 자체도 유지보수가 필요한 점, Master와 소통하기 위해 pull/push 방식을 활용할 시 추가 포트를 열어야 한다는 보안 이슈가 있다

### Large Community Versus Small Community + Mature Versus Cutting Edge

- (대충 Terraform 빠르게 성장 중이니까 형 믿고 쓰라는 말)

### Using Multiple Tools Together

1. Provisioning plus configuration management : 서버까지는 Terraform, 서버 내부 어플리케이션은 Ansible
2. Provisioning plus server templating : 서버까지는 Terraform, 가상머신은 Packer (어림도 없다)
3. Provisioning plus server templating plus orchestration : 서버까지는 Terraform, 가상머신은 Packer, 그 위에 어플리케이션은 콘테이너 (이럴 바에는 쿠버네티스 쓰는게..?)

> 결론 : Terraform이 세계 제일임!